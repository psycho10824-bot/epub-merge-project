# -*- coding: utf-8 -*-
import os
import re
import json
import zipfile
import tempfile
import shutil
import traceback
import xml.etree.ElementTree as ET
import subprocess

import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import ttkbootstrap as tb

# ë“œë˜ê·¸ì•¤ë“œë¡­(ì„ íƒ)
try:
    from tkinterdnd2 import DND_FILES, TkinterDnD
    DND_AVAILABLE = True
except Exception:
    DND_AVAILABLE = False

# ì‚¬ìš©ì í™ˆì— ì €ì¥ ìœ„ì¹˜ ê¸°ì–µ íŒŒì¼
CONFIG_PATH = os.path.join(os.path.expanduser("~"), ".epub_merge_config.json")


# ----------------------- ì •ë ¬ ìœ í‹¸ (ë‹¨í–‰ë³¸ ì „ìš©) -----------------------
def _volume_sort_key_from_basename(basename: str):
    """
    ë‹¨í–‰ë³¸(ê¶Œ) ì •ë ¬ ì „ìš© í‚¤:
      (0, ê¶Œë²ˆí˜¸, ì´ë¦„)  â†’ ìˆ«ì ê¶Œ
      (1, rank,  ì´ë¦„)  â†’ íŠ¹ìˆ˜ ê¶Œ(ì™¸ì „/íŠ¹ë³„ì™¸ì „/ë²ˆì™¸/ë¶€ë¡/ì¦ë³´/ê°œì •)
      (2, 0,    ì´ë¦„)  â†’ ê¸°íƒ€
    """
    name = os.path.splitext(basename)[0]

    # 1) 'ìˆ«ìë¶€ ìˆ«ìê¶Œ' (ì˜ˆ: "1ë¶€ 2ê¶Œ") ìš°ì„  ì²˜ë¦¬
    m = re.search(r"(\d+)\s*ë¶€\s*(\d+)\s*ê¶Œ", name)
    if m:
        part = int(m.group(1))   # ë¶€ ë²ˆí˜¸
        vol = int(m.group(2))    # ê¶Œ ë²ˆí˜¸
        return (0, part * 1000 + vol, name)

    # 1-2) 'ìˆ«ì ê¶Œ'ë§Œ ìˆëŠ” ì¼ë°˜ ë‹¨í–‰ë³¸ (ì˜ˆ: "3ê¶Œ")
    m = re.search(r"(\d+)\s*ê¶Œ", name)
    if m:
        return (0, int(m.group(1)), name)

    # 2) íŠ¹ìˆ˜ ê¶Œ
    specials_order = [
        ("ì™¸ì „", 1),
        ("íŠ¹ë³„ì™¸ì „", 2),
        ("ë²ˆì™¸", 3),
        ("ë¶€ë¡", 4),
        ("ì¦ë³´", 5),
        ("ê°œì •", 6),
    ]
    for token, rank in specials_order:
        if token in name:
            return (1, rank, name)

    # 3) ìˆ«ìë§Œ ë“±ì¥(ë°±ì—…ìš©)
    m2 = re.search(r"(\d+)", name)
    if m2:
        return (0, int(m2.group(1)), name)

    # 4) ê¸°íƒ€
    return (2, 0, name)


# ----------------------------- ì•± -----------------------------
class App:
    def __init__(self, window, dnd_enabled=False):
        self.window = window
        self.dnd_enabled = dnd_enabled

        self.window.title("EPUB í•©ì¹˜ê¸°(forê°ì)")
        self.window.geometry("840x700")
        self.window.minsize(740, 700)

        self.epub_paths: list[str] = []
        self.auto_sort_var = tk.BooleanVar(value=True)
        self.mode_var = tk.StringVar(value="serial")  # serial | volume
        self.toc_use_titles_var = tk.BooleanVar(value=False)  # âœ… ê°€ëŠ¥í•˜ë©´ ì†Œì œëª©ìœ¼ë¡œ ëª©ì°¨ ë§Œë“¤ê¸°

        # ìˆ«ì ì…ë ¥(ë³´ì—¬ì£¼ê¸°ìš©)
        self.serial_start_var = tk.StringVar(value="1")
        self.serial_end_var = tk.StringVar(value="6")
        self.volume_start_var = tk.StringVar(value="1")
        self.volume_end_var = tk.StringVar(value="6")

        # ì €ì¥ ìœ„ì¹˜ ë³µì›
        default_dir = os.getcwd()
        if os.path.exists(CONFIG_PATH):
            try:
                with open(CONFIG_PATH, "r", encoding="utf-8") as f:
                    cfg = json.load(f)
                default_dir = cfg.get("last_output_dir", default_dir)
            except Exception:
                pass
        self.last_output_dir = default_dir

        self._build_ui()
        self._sync_labels()  # ì´ˆê¸° ë¼ë²¨/ì…ë ¥ì¹¸ í…ìŠ¤íŠ¸ ë™ê¸°í™”

    # ----------------------------- UI ë¹Œë“œ -----------------------------
    def _build_ui(self):
        root = ttk.Frame(self.window, padding=8)
        root.pack(fill="both", expand=True)

        # ìƒë‹¨ íƒ­ë°”
        self.tabbar = ttk.Notebook(root)
        self.tab_serial = ttk.Frame(self.tabbar)
        self.tab_volume = ttk.Frame(self.tabbar)
        self.tabbar.add(self.tab_serial, text="ì—°ì¬ë³¸ í•©ì¹˜ê¸°")
        self.tabbar.add(self.tab_volume, text="ë‹¨í–‰ë³¸ í•©ì¹˜ê¸°")
        self.tabbar.pack(fill="x")
        self.tabbar.bind("<<NotebookTabChanged>>", self._on_tab_changed)

        # íŒŒì¼ ë¦¬ìŠ¤íŠ¸
        file_frame = ttk.LabelFrame(root, text="ë³‘í•©í•  EPUB ëª©ë¡ (ë“œë˜ê·¸ ê°€ëŠ¥)")
        file_frame.pack(fill="both", expand=False, pady=(8, 4))

        list_wrap = ttk.Frame(file_frame)
        list_wrap.pack(fill="both", expand=True, padx=4, pady=4)

        self.listbox = tk.Listbox(list_wrap, height=10)
        self.listbox.pack(side="left", fill="both", expand=True)
        sb = ttk.Scrollbar(list_wrap, orient="vertical", command=self.listbox.yview)
        sb.pack(side="right", fill="y")
        self.listbox.config(yscrollcommand=sb.set)

        if self.dnd_enabled:
            try:
                self.listbox.drop_target_register(DND_FILES)
                self.listbox.dnd_bind("<<Drop>>", self._on_drop_files)
            except Exception:
                pass

        # íŒŒì¼ ë²„íŠ¼ë“¤
        btn_row = ttk.Frame(file_frame)
        btn_row.pack(fill="x", padx=4, pady=(0, 6))
        ttk.Button(btn_row, text="íŒŒì¼ ì¶”ê°€", command=self._add_files).pack(side="left", padx=2)
        ttk.Button(btn_row, text="ì„ íƒ ì‚­ì œ", command=self._remove_selected).pack(side="left", padx=2)
        ttk.Button(btn_row, text="ì „ì²´ ì§€ìš°ê¸°", command=self._clear_all).pack(side="left", padx=2)
        ttk.Button(btn_row, text="ìœ„ë¡œ â†‘", command=self._move_up).pack(side="left", padx=2)
        ttk.Button(btn_row, text="ì•„ë˜ë¡œ â†“", command=self._move_down).pack(side="left", padx=2)
        ttk.Checkbutton(
            btn_row,
            text="íŒŒì¼ ì´ë¦„ìœ¼ë¡œ ìë™ ì •ë ¬",
            variable=self.auto_sort_var,
            command=self._maybe_resort,
        ).pack(side="left", padx=8)

        # âœ… ìƒˆ ì²´í¬ë°•ìŠ¤: ê°€ëŠ¥í•˜ë©´ ì†Œì œëª©ìœ¼ë¡œ ëª©ì°¨ ë§Œë“¤ê¸°
        ttk.Checkbutton(
            btn_row,
            text="ê°€ëŠ¥í•˜ë©´ ì†Œì œëª©ìœ¼ë¡œ ëª©ì°¨ ë§Œë“¤ê¸°",
            variable=self.toc_use_titles_var,
        ).pack(side="left", padx=8)

        # ì €ì¥ ìœ„ì¹˜
        out_frame = ttk.LabelFrame(root, text="ì €ì¥ ìœ„ì¹˜")
        out_frame.pack(fill="x", pady=6)
        self.out_entry = ttk.Entry(out_frame)
        self.out_entry.pack(side="left", fill="x", expand=True, padx=6, pady=6)
        self.out_entry.insert(0, self.last_output_dir)
        ttk.Button(out_frame, text="ì°¾ì•„ë³´ê¸°", command=self._choose_outdir).pack(side="left", padx=6)

        # ì§„í–‰ ìƒíƒœ
        log_frame = ttk.LabelFrame(root, text="ì§„í–‰ ìƒíƒœ")
        log_frame.pack(fill="both", expand=True, pady=6)
        self.log_text = tk.Text(log_frame, height=12)
        self.log_text.pack(fill="both", expand=True)

        self.progress = ttk.Progressbar(root, orient="horizontal", mode="determinate")
        self.progress.configure(length=400)
        self.progress.pack(fill="x", pady=6, ipady=3)

        # ë³‘í•© ì‹œì‘ ë²„íŠ¼
        ttk.Button(root, text="ğŸš€ ë³‘í•© ì‹œì‘", command=self._start_merge).pack(fill="x", pady=(0, 6))

    # -------------------------- ì´ë²¤íŠ¸/ë™ì‘ --------------------------
    def _on_tab_changed(self, _evt=None):
        idx = self.tabbar.index(self.tabbar.select())
        new_mode = "serial" if idx == 0 else "volume"
        self.mode_var.set(new_mode)
        self._maybe_resort()

    def _sync_labels(self):
        # (í˜„ì¬ íƒ­ì— ë”°ë¼ ë¼ë²¨ ë°”ê¿”ì£¼ëŠ” ë¡œì§ë§Œ ìœ ì§€)
        pass

    # -------------------------- ë³‘í•© ì‹œì‘ ì§„ì…ì  --------------------------
    def _start_merge(self):
        self.progress["value"] = 0
        self.log_text.delete("1.0", "end")

        if not self.epub_paths:
            self._log("âš  ë³‘í•©í•  EPUB íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
            return

        out_dir = self.out_entry.get().strip()
        if not out_dir or not os.path.isdir(out_dir):
            messagebox.showerror("ì˜¤ë¥˜", "ìœ íš¨í•œ ì €ì¥ ìœ„ì¹˜ë¥¼ ì„ íƒí•´ ì£¼ì„¸ìš”.")
            return

        mode = self.mode_var.get()
        self._log(f"ëª¨ë“œ: {mode} / íŒŒì¼ {len(self.epub_paths)}ê°œ")
        self._log(f"ì €ì¥ ìœ„ì¹˜: {out_dir}")

        if mode == "serial":
            try:
                out_path = self._merge_serial(out_dir)
                self.progress["value"] = 100
                self._log("âœ… ì—°ì¬ë³¸ ë³‘í•© ì™„ë£Œ")

                if out_path and os.path.exists(out_path):
                    try:
                        if os.name == "nt":
                            subprocess.Popen([
                                "explorer",
                                "/select,",
                                os.path.normpath(out_path),
                            ])
                        else:
                            subprocess.Popen([
                                "xdg-open",
                                os.path.dirname(out_path),
                            ])
                    except Exception:
                        self._log("âš  íŒŒì¼ ìœ„ì¹˜ ì—´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
            except Exception as e:
                self._log(f"âŒ ì˜¤ë¥˜ ë°œìƒ: {e}")
                traceback.print_exc()
        else:
            self._log("â„¹ ë‹¨í–‰ë³¸ ë³‘í•©ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (ì •ë ¬/UIë§Œ ë™ì‘)")
            self.progress["value"] = 100

    # -------------------------- ì—°ì¬ë³¸ ë³‘í•© ë¡œì§ --------------------------
    def _merge_serial(self, out_dir: str):
        """
        ì—°ì¬ë³¸ EPUBë“¤ì„ í•˜ë‚˜ë¡œ í•©ì¹˜ê³ 
        chapter_001, 002 ... ë¡œ ë¦¬ë„¤ì„ + toc.ncx(ì°¨ë¡€) ìƒì„±.
        - íŒŒì¼ëª…ë¿ ì•„ë‹ˆë¼ 'íŒŒì¼ ë‚´ë¶€ì— ê¸°ì¡´ ëª©ì°¨ê°€ ìˆëŠ”ì§€'ë„ ì²´í¬í•˜ì—¬
          íŠ¹ì „/ì™¸ì „ EPUBë¥¼ í•˜ë‚˜ì˜ ë¶€ëª¨ í•­ëª© ì•„ë˜ì— ë¬¶ì–´ì¤€ë‹¤.
        """
        # --- 0) íŒŒì¼ëª…ì—ì„œ ì‹œì‘/ë í™”ìˆ˜ ë° ì œëª© ì½”ì–´ ì¶”ì¶œ ---
        def extract_num_for_range(name: str):
            base = os.path.splitext(name)[0]
            patterns = [
                r"\((\d+)\s*~",          # (185~194í™”)
                r"(\d+)\s*-\s*\d+\s*í™”", # 1-184í™”
                r"(\d+)\s*í™”",           # 595í™”
                r"(\d+)\s*ê¶Œ",           # 3ê¶Œ
                r"(\d+)",                # ê·¸ëƒ¥ ìˆ«ì
            ]
            for pat in patterns:
                m = re.search(pat, base)
                if m:
                    try:
                        return int(m.group(1))
                    except ValueError:
                        pass
            return None

        first_name = os.path.basename(self.epub_paths[0])
        last_name = os.path.basename(self.epub_paths[-1])

        start_no = extract_num_for_range(first_name)
        end_no = extract_num_for_range(last_name)

        # ğŸ”¹ ëª©ì°¨ìš© / íŒŒì¼ëª…ìš© ë²ˆí˜¸ë¥¼ ë¶„ë¦¬í•´ì„œ ì‚¬ìš©
        toc_start_no = start_no          # toc.ncxì—ì„œ ì¦ê°€ì‹œí‚¤ë©° ì“°ëŠ” ë²ˆí˜¸
        range_start_no = start_no        # ìµœì¢… íŒŒì¼ëª…ì— ë“¤ì–´ê°ˆ ì‹œì‘ í™”ìˆ˜

        base_title = os.path.splitext(first_name)[0]
        title_core = re.sub(
            r'\s*\(?\d+[^)]*\)?\s*(í™”|ê¶Œ)?\s*(ì™¸ì „)?\s*$',
            '',
            base_title
        ).rstrip()
        if not title_core:
            title_core = base_title

        tmp_root = tempfile.mkdtemp(prefix="epub_merge_")
        self._log(f"ì„ì‹œ ì‘ì—… í´ë”: {tmp_root}")
        out_path = None

        try:
            # 1) ì²« ë²ˆì§¸ EPUBë¥¼ ë² ì´ìŠ¤ë¡œ ì¶”ì¶œ
            base_epub = self.epub_paths[0]
            self._log(f"1/3: ë² ì´ìŠ¤ EPUB ì¶”ì¶œ: {os.path.basename(base_epub)}")
            base_dir = self._extract_epub_to(tmp_root, base_epub)

            base_opf = self._find_opf_path(base_dir)
            if not base_opf:
                raise RuntimeError("ë² ì´ìŠ¤ EPUBì—ì„œ content.opfë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            self._log(f"ë² ì´ìŠ¤ OPF: {os.path.relpath(base_opf, base_dir)}")

            tree = ET.parse(base_opf)
            root = tree.getroot()
            ns_uri = root.tag.split("}")[0].strip("{")
            ns = {"opf": ns_uri}

            manifest = root.find("opf:manifest", ns)
            spine = root.find("opf:spine", ns)
            if manifest is None or spine is None:
                raise RuntimeError("ë² ì´ìŠ¤ EPUBì˜ manifest ë˜ëŠ” spineì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

            # --- 1) ë² ì´ìŠ¤ EPUBì˜ í…ìŠ¤íŠ¸ ë””ë ‰í„°ë¦¬/ì•„ì´í…œ ë§µ íŒŒì•… ---
            text_dir = ""
            id_to_item = {}
            for item in manifest.findall("opf:item", ns):
                item_id = item.get("id", "")
                href = item.get("href", "")
                media = item.get("media-type", "")
                id_to_item[item_id] = item
                if not text_dir and "html" in media:
                    text_dir = os.path.dirname(href)

            if not text_dir:
                text_dir = ""
            self._log(f"ë³¸ë¬¸ ë””ë ‰í„°ë¦¬ ì¶”ì •: '{text_dir or '(ë£¨íŠ¸)'}'")

            base_opf_dir = os.path.dirname(base_opf)
            full_text_dir = os.path.join(base_opf_dir, text_dir) if text_dir else base_opf_dir
            os.makedirs(full_text_dir, exist_ok=True)

            # --- 2) ë² ì´ìŠ¤ EPUBì˜ spine í…ìŠ¤íŠ¸ë¥¼ chapter_001... ë¡œ ë¦¬ë„¤ì„ ---
            used_ids = {it.get("id", "") for it in manifest.findall("opf:item", ns)}
            old_to_new_id: dict[str, str] = {}
            base_chapter_count = 0

            for itemref in list(spine.findall("opf:itemref", ns)):
                idref = itemref.get("idref", "")
                item = id_to_item.get(idref)
                if item is None:
                    continue

                media = item.get("media-type", "")
                href = item.get("href", "")
                if "html" not in media:
                    continue

                lower_href = href.lower()
                if any(key in lower_href for key in ["cover", "nav", "toc", "ncx"]):
                    continue

                base_chapter_count += 1

                new_id = f"chap_{base_chapter_count:03d}"
                while new_id in used_ids:
                    base_chapter_count += 1
                    new_id = f"chap_{base_chapter_count:03d}"
                used_ids.add(new_id)

                fname = f"chapter_{base_chapter_count:03d}.xhtml"
                if text_dir:
                    new_href = f"{text_dir}/{fname}"
                else:
                    new_href = fname

                old_full = os.path.join(base_opf_dir, href.replace("/", os.sep))
                new_full = os.path.join(base_opf_dir, new_href.replace("/", os.sep))
                os.makedirs(os.path.dirname(new_full), exist_ok=True)
                try:
                    if os.path.abspath(old_full) != os.path.abspath(new_full) and os.path.exists(old_full):
                        os.replace(old_full, new_full)
                except Exception:
                    pass

                item.set("id", new_id)
                item.set("href", new_href)
                old_to_new_id[idref] = new_id

                self._log(f"  ğŸ” ê¸°ë³¸ ë³¸ë¬¸ ë¦¬ë„¤ì„: {href} â†’ {new_href}")

            for itemref in spine.findall("opf:itemref", ns):
                idref = itemref.get("idref", "")
                if idref in old_to_new_id:
                    itemref.set("idref", old_to_new_id[idref])

            used_ids = {it.get("id", "") for it in manifest.findall("opf:item", ns)}

            # ğŸ”¹ EPUB(íŒŒì¼)ë³„ë¡œ chapter ë²”ìœ„ë¥¼ ê¸°ë¡í•´ì„œ
            #    ë‚˜ì¤‘ì— íŠ¹ì „/ì™¸ì „ íŒŒì¼ì„ í•œ ë¬¶ìŒìœ¼ë¡œ ë³´ì—¬ì¤„ ë•Œ ì‚¬ìš©
            epub_groups = []
            epub_groups.append({
                "index": 0,                 # ì²« ë²ˆì§¸ EPUB (ë² ì´ìŠ¤)
                "start": 1,
                "end": base_chapter_count,
                "is_special": False,
                "title": title_core,        # ì‹œë¦¬ì¦ˆ ê¸°ë³¸ ì œëª©
            })

            # ë² ì´ìŠ¤ì—ì„œ ì‚¬ìš©í•œ chapter ë²ˆí˜¸ ë‹¤ìŒë¶€í„° ì‹œì‘
            chapter_index = base_chapter_count + 1

            # --- 3) ë‚˜ë¨¸ì§€ EPUBì—ì„œ ë³¸ë¬¸ì„ ê°€ì ¸ì™€ì„œ ì°¨ë¡€ëŒ€ë¡œ ë’¤ì— ë¶™ì´ê¸° ---
            for idx, epub_path in enumerate(self.epub_paths[1:], start=2):
                self._log(f"2/3: ì¶”ê°€ EPUB #{idx} ì²˜ë¦¬ ì¤‘: {os.path.basename(epub_path)}")
                src_dir = self._extract_epub_to(tmp_root, epub_path)
                src_opf = self._find_opf_path(src_dir)
                if not src_opf:
                    self._log("  âš  OPFë¥¼ ì°¾ì§€ ëª»í•´ ê±´ë„ˆëœë‹ˆë‹¤.")
                    continue

                # ì´ EPUBì—ì„œ ìƒì„±ë  chapter_XXX ë²”ìœ„ ì‹œì‘
                group_start = chapter_index

                start_ref = [chapter_index]
                self._append_serial_chapters_from_epub(
                    src_opf,
                    base_opf_dir,
                    text_dir,
                    manifest,
                    spine,
                    ns,
                    used_ids,
                    start_index_ref=start_ref,
                )
                chapter_index = start_ref[0]

                # ì´ EPUBì—ì„œ ì‹¤ì œë¡œ ì¶”ê°€ëœ chapter ë²”ìœ„
                group_end = chapter_index - 1
                if group_end >= group_start:
                    base_epub_name = os.path.basename(epub_path)
                    title_epub = os.path.splitext(base_epub_name)[0]


                    is_special_name = False
                    # ğŸ”¹ íŒŒì¼ ì•ˆì— ìì²´ toc.ncx(navPoint 2ê°œ ì´ìƒ)ê°€ ìˆìœ¼ë©´ íŠ¹ì „ í›„ë³´
                    has_internal_toc = self._epub_has_multi_nav(src_opf)

                    # ğŸ”¹ "ì´ë¦„ìœ¼ë¡œ íŠ¹ì „" ì´ê±°ë‚˜ "ë‚´ë¶€ ëª©ì°¨ ìˆëŠ” EPUB" ì´ê³ 
                    #    chapterê°€ 2ê°œ ì´ìƒì¸ ê²½ìš°ë§Œ ë¬¶ìŒ ì²˜ë¦¬
                    is_special_group = has_internal_toc and (group_end > group_start)

                    epub_groups.append({
                        "index": idx - 1,          # 0: ì²« EPUB, 1: ë‘ ë²ˆì§¸ EPUB ...
                        "start": group_start,
                        "end": group_end,
                        "is_special": is_special_group,
                        "title": title_epub,
                    })

            # --- 4) toc.ncx ìƒì„± ë˜ëŠ” ê°±ì‹  ---
            opf_dir = os.path.dirname(base_opf)
            ncx_path = None

            for item in manifest.findall("opf:item", ns):
                if (item.get("media-type") or "").lower() == "application/x-dtbncx+xml":
                    ncx_path = os.path.join(opf_dir, item.get("href").replace("/", os.sep))
                    break

            if not ncx_path:
                ncx_path = os.path.join(opf_dir, "toc.ncx")
                ET.SubElement(
                    manifest,
                    f"{{{ns['opf']}}}item",
                    {
                        "id": "ncx",
                        "href": "toc.ncx",
                        "media-type": "application/x-dtbncx+xml",
                    },
                )

            spine.set("toc", "ncx")

            # ncx íŒŒì¼ êµ¬ì„±
            ncx_root = ET.Element("ncx", {
                "xmlns": "http://www.daisy.org/z3986/2005/ncx/",
                "version": "2005-1",
            })

            head = ET.SubElement(ncx_root, "head")
            ET.SubElement(head, "meta", {"name": "dtb:uid", "content": "merge-uid"})
            ET.SubElement(head, "meta", {"name": "dtb:depth", "content": "1"})
            ET.SubElement(head, "meta", {"name": "dtb:totalPageCount", "content": "0"})
            ET.SubElement(head, "meta", {"name": "dtb:maxPageNumber", "content": "0"})

            docTitle = ET.SubElement(ncx_root, "docTitle")
            ET.SubElement(docTitle, "text").text = title_core

            navMap = ET.SubElement(ncx_root, "navMap")

            play_order = 1
            use_titles = self.toc_use_titles_var.get()
            episode_no = toc_start_no  # ğŸ”¹ ëª©ì°¨ìš© ë²ˆí˜¸ (íŒŒì¼ëª…ìš©ê³¼ ë¶„ë¦¬)

            # chapter_001, chapter_002 ... ìˆœì„œë¥¼ ì„¸ê¸° ìœ„í•œ ì¹´ìš´í„°
            chapter_counter = 0

            # íŠ¹ì „/ì™¸ì „ EPUBë§ˆë‹¤ ë¶€ëª¨ navPointë¥¼ ì €ì¥
            group_parents = {}

            def find_group_for_chapter(ch_index: int):
                """í•´ë‹¹ chapter ë²ˆí˜¸ê°€ ì†í•œ íŠ¹ì „/ì™¸ì „ EPUB ê·¸ë£¹ì„ ì°¾ìŒ."""
                for g in epub_groups:
                    if g.get("is_special") and g["start"] <= ch_index <= g["end"]:
                        return g
                return None

            for itemref in spine.findall("opf:itemref", ns):
                idref = itemref.get("idref")
                item = manifest.find(f"opf:item[@id='{idref}']", ns)
                if item is None:
                    continue

                href = item.get("href") or ""
                if not href:
                    continue

                href_norm = href.replace("\\", "/")
                full_path = os.path.join(opf_dir, href_norm.replace("/", os.sep))
                media = item.get("media-type", "") or ""
                lower_href = href_norm.lower()

                # --- â‘  í‘œì§€/ë³¸ë¬¸ íŒë³„ ---
                is_cover = (
                    "cover" in lower_href
                    and "html" in media
                )
                is_main_html = (
                    "html" in media
                    and not any(key in lower_href for key in ["cover", "nav", "toc", "ncx"])
                )

                if is_cover:
                    # í‘œì§€ëŠ” í•­ìƒ ìµœìƒìœ„ì— 'í‘œì§€'ë¡œ í•œ ì¤„
                    label = "í‘œì§€"
                    parent_navmap = navMap

                elif is_main_html:
                    # nav/toc íŒŒì¼ì€ ë¶€ëª¨ navPoint ì•ˆì— ë“¤ì–´ê°€ë©´ ì•ˆ ë¨ â†’ ì™„ì „ ì œì™¸
                    # ì°¨ë¡€ / ëª©ì°¨ / table of contents íŒŒì¼ì€ ì™„ì „íˆ ì œì™¸
                    toc_block_keywords = [
                        "nav.xhtml", "toc", "table", "book_table",
                        "contents", "content", "ëª©ì°¨", "ì°¨ë¡€"
                    ]
                    if any(key in lower_href for key in toc_block_keywords):
                        continue

                    # ë³¸ë¬¸ chapter
                    chapter_counter += 1
                    group = find_group_for_chapter(chapter_counter)
                    if group:
                        # ğŸ”¹ íŠ¹ì „/ì™¸ì „ EPUB â†’ ë¶€ëª¨ navPoint(ì˜ˆ: '... IF íŠ¹ì „')
                        g_idx = group["index"]
                        if g_idx not in group_parents:
                            parent = ET.SubElement(navMap, "navPoint", {
                                "id": f"navPoint-{play_order}",
                                "playOrder": str(play_order),
                            })
                            play_order += 1

                            navLabel = ET.SubElement(parent, "navLabel")
                            ET.SubElement(navLabel, "text").text = group["title"]

                            group_parents[g_idx] = parent

                        parent_navmap = group_parents[g_idx]
                    else:
                        # ì¼ë°˜ ì—°ì¬ í™”ìˆ˜ëŠ” ê·¸ëŒ€ë¡œ ìµœìƒìœ„ì— ë°°ì¹˜
                        parent_navmap = navMap

                    # ë¼ë²¨ ê²°ì •: ì†Œì œëª© ìš°ì„ , ì—†ìœ¼ë©´ 'ní™”'
                    label = None
                    if use_titles:
                        label = self._extract_chapter_title(full_path)

                    if not label:
                        if episode_no is not None:
                            label = f"{episode_no}í™”"
                            episode_no += 1
                        else:
                            label = idref
                else:
                    # nav.xhtml, toc.ncx ë“±ì€ ëª©ì°¨ì—ì„œ ì œì™¸
                    continue

                navPoint = ET.SubElement(parent_navmap, "navPoint", {
                    "id": f"navPoint-{play_order}",
                    "playOrder": str(play_order),
                })
                play_order += 1

                navLabel = ET.SubElement(navPoint, "navLabel")
                ET.SubElement(navLabel, "text").text = label
                ET.SubElement(navPoint, "content", {"src": href_norm})

            ET.ElementTree(ncx_root).write(ncx_path, encoding="utf-8", xml_declaration=True)
            self._log(f"ğŸ“Œ toc.ncx ìƒì„±/ê°±ì‹  ì™„ë£Œ: {ncx_path}")

            # --- 5) ìˆ˜ì •ëœ OPF ì €ì¥ ---
            tree.write(base_opf, encoding="utf-8", xml_declaration=True)

            # --- 6) ìµœì¢… EPUB íŒŒì¼ ì´ë¦„ êµ¬ì„± ë° ì••ì¶• ---
            # ì „ë¶€ ì™¸ì „ì¸ì§€ í™•ì¸ (ì´ ê²½ìš° íŒŒì¼ëª…ì— (ì™¸ì „) ë¶™ì´ê¸°)
            all_extra = all('ì™¸ì „' in os.path.basename(p) for p in self.epub_paths)

            if range_start_no is not None and end_no is not None:
                range_part = f"{range_start_no}-{end_no}í™”"
                extra_part = " (ì™¸ì „)" if all_extra and "ì™¸ì „" not in title_core else ""
                out_filename = f"{title_core} {range_part}{extra_part}.epub"
            else:
                base_name = os.path.basename(self.epub_paths[0])
                name_no_ext, _ = os.path.splitext(base_name)
                out_filename = f"{name_no_ext}_í•©ë³¸.epub"

            out_path = os.path.join(out_dir, out_filename)
            self._log(f"3/3: ìµœì¢… EPUB ì••ì¶•: {out_path}")
            self._zip_epub(base_dir, out_path)

        finally:
            try:
                shutil.rmtree(tmp_root)
                self._log("ì„ì‹œ ì‘ì—… í´ë” ì‚­ì œ ì™„ë£Œ")
            except Exception:
                self._log("âš  ì„ì‹œ ì‘ì—… í´ë” ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì§€ë§Œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.")

        return out_path

    # ---------------------- ë‚´ë¶€ ëª©ì°¨ ìœ ë¬´ íŒë³„ ----------------------
    def _epub_has_multi_nav(self, opf_path: str) -> bool:
        """
        ì£¼ì–´ì§„ OPFë¥¼ ê°€ì§„ EPUB ì•ˆì—
        toc.ncx(navMap/navPoint)ê°€ 2ê°œ ì´ìƒ ìˆìœ¼ë©´ True.
        (ê¸°ì¡´ì— ìì²´ ëª©ì°¨ê°€ ìˆëŠ” 'íŠ¹ì „/ì™¸ì „ ë¯¸ë‹ˆë¶' ê°™ì€ ê²½ìš°ë¥¼ ì¡ê¸° ìœ„í•¨)
        """
        try:
            opf_dir = os.path.dirname(opf_path)
            tree = ET.parse(opf_path)
            root = tree.getroot()
            ns_uri = root.tag.split("}")[0].strip("{")
            ns = {"opf": ns_uri}

            manifest = root.find("opf:manifest", ns)
            if manifest is None:
                return False

            ncx_href = None
            for item in manifest.findall("opf:item", ns):
                if (item.get("media-type") or "").lower() == "application/x-dtbncx+xml":
                    ncx_href = item.get("href")
                    break

            if not ncx_href:
                return False

            ncx_path = os.path.join(opf_dir, ncx_href.replace("/", os.sep))
            if not os.path.isfile(ncx_path):
                return False

            ncx_tree = ET.parse(ncx_path)
            ncx_root = ncx_tree.getroot()
            # ê¸°ë³¸ NCX ë„¤ì„ìŠ¤í˜ì´ìŠ¤
            ns_ncx_uri = ncx_root.tag.split("}")[0].strip("{")
            ns_ncx = {"ncx": ns_ncx_uri}

            navmap = ncx_root.find("ncx:navMap", ns_ncx)
            if navmap is None:
                return False

            navpoints = list(navmap.findall("ncx:navPoint", ns_ncx))
            # navPointê°€ 2ê°œ ì´ìƒì´ë©´ 'ìì²´ ëª©ì°¨ê°€ ìˆëŠ” EPUB'ë¡œ ê°„ì£¼
            return len(navpoints) >= 2
        except Exception:
            return False

    # ---------------------- ì†Œì œëª© ì¶”ì¶œ í—¬í¼ ----------------------
    def _extract_chapter_title(self, chapter_path: str) -> str | None:
        """XHTML íŒŒì¼ì—ì„œ ì²« ë²ˆì§¸ ì œëª©(h1~h6 or chapter-header)ì„ ì°¾ì•„ í…ìŠ¤íŠ¸ë¥¼ ë¦¬í„´."""
        if not os.path.isfile(chapter_path):
            return None
        try:
            tree = ET.parse(chapter_path)
            root = tree.getroot()
        except Exception:
            return None

        # 1ìˆœìœ„: h1~h6
        heading_tags = ("h1", "h2", "h3", "h4", "h5", "h6")
        for elem in root.iter():
            tag = elem.tag
            if not isinstance(tag, str):
                continue
            short = tag.split("}")[-1]
            if short in heading_tags:
                text = "".join(elem.itertext()).strip()
                if text:
                    return text

        # 2ìˆœìœ„: classì— chapter-header / chapter-title ë“±ì´ ë“¤ì–´ê°„ ìš”ì†Œ
        for elem in root.iter():
            cls = elem.get("class") or ""
            if any(key in cls for key in ("chapter-header", "chapter_title", "chapter-title")):
                text = "".join(elem.itertext()).strip()
                if text:
                    return text

        return None

    # ---------------------- ê¸°íƒ€ ìœ í‹¸ë“¤ ----------------------
    def _extract_epub_to(self, tmp_root: str, epub_path: str) -> str:
        name = os.path.splitext(os.path.basename(epub_path))[0]
        out_dir = os.path.join(tmp_root, name)
        os.makedirs(out_dir, exist_ok=True)
        with zipfile.ZipFile(epub_path, "r") as zf:
            zf.extractall(out_dir)
        return out_dir

    def _find_opf_path(self, root_dir: str) -> str | None:
        for dirpath, _dirnames, filenames in os.walk(root_dir):
            for fn in filenames:
                if fn.lower().endswith(".opf"):
                    return os.path.join(dirpath, fn)
        return None

    def _append_serial_chapters_from_epub(
        self,
        src_opf_path: str,
        base_opf_dir: str,
        text_dir: str,
        base_manifest,
        base_spine,
        ns,
        used_ids: set[str],
        start_index_ref: list[int],
    ):
        tree = ET.parse(src_opf_path)
        root = tree.getroot()
        ns_uri = root.tag.split("}")[0].strip("{")
        local_ns = {"opf": ns_uri}

        manifest = root.find("opf:manifest", local_ns)
        spine = root.find("opf:spine", local_ns)
        if manifest is None or spine is None:
            return

        src_opf_dir = os.path.dirname(src_opf_path)

        id_to_item = {}
        for item in manifest.findall("opf:item", local_ns):
            item_id = item.get("id", "")
            id_to_item[item_id] = item

        for itemref in spine.findall("opf:itemref", local_ns):
            idref = itemref.get("idref", "")
            src_item = id_to_item.get(idref)
            if src_item is None:
                continue

            media = src_item.get("media-type", "")
            href = src_item.get("href", "")
            if "html" not in media:
                continue

            lower_href = href.lower()
                # í‘œì§€/ì°¨ë¡€(nav/toc/table/book_table) ë“±ì€ ë³¸ë¬¸ chapterë¡œ ì·¨ê¸‰í•˜ì§€ ì•ŠìŒ
            exclude_keywords = [
                    "cover", "nav", "toc", "ncx",
                    "book_table", "table", "contents", "content",
                    "ì°¨ë¡€", "ëª©ì°¨"
                ]
            if any(key in lower_href for key in exclude_keywords):
                continue

            src_file = os.path.join(src_opf_dir, href)
            if not os.path.isfile(src_file):
                continue

            chapter_index = start_index_ref[0]
            new_id = f"chap_{chapter_index:03d}"
            while new_id in used_ids:
                chapter_index += 1
                new_id = f"chap_{chapter_index:03d}"

            start_index_ref[0] = chapter_index + 1
            used_ids.add(new_id)

            fname = f"chapter_{chapter_index:03d}.xhtml"
            if text_dir:
                new_href = f"{text_dir}/{fname}"
            else:
                new_href = fname

            dest_file = os.path.join(base_opf_dir, new_href.replace("/", os.sep))
            os.makedirs(os.path.dirname(dest_file), exist_ok=True)

            with open(src_file, "rb") as rf, open(dest_file, "wb") as wf:
                wf.write(rf.read())

            ET.SubElement(
                base_manifest,
                f"{{{ns['opf']}}}item",
                {
                    "id": new_id,
                    "href": new_href,
                    "media-type": media,
                },
            )

            ET.SubElement(
                base_spine,
                f"{{{ns['opf']}}}itemref",
                {
                    "idref": new_id,
                },
            )

            self._log(f"  â• chapter {chapter_index:03d} ì¶”ê°€: {new_href}")

    def _zip_epub(self, src_dir: str, out_path: str):
        if os.path.exists(out_path):
            os.remove(out_path)

        with zipfile.ZipFile(out_path, "w") as zf:
            mime_path = os.path.join(src_dir, "mimetype")
            if os.path.isfile(mime_path):
                zf.write(mime_path, "mimetype", compress_type=zipfile.ZIP_STORED)

            for root, _dirs, files in os.walk(src_dir):
                for fn in files:
                    full = os.path.join(root, fn)
                    rel = os.path.relpath(full, src_dir)
                    if rel == "mimetype":
                        continue
                    zf.write(full, rel, compress_type=zipfile.ZIP_DEFLATED)

    # ------------- íŒŒì¼ ë¦¬ìŠ¤íŠ¸ ì¡°ì‘ -------------
    def _on_drop_files(self, event):
        paths = self.window.splitlist(event.data)
        added = 0
        for p in paths:
            p = p.strip()
            if p.lower().endswith(".epub"):
                self.epub_paths.append(p)
                added += 1
        if added:
            self._maybe_resort()
            self._refresh_list()

    def _add_files(self):
        files = filedialog.askopenfilenames(
            title="ePub íŒŒì¼ ì„ íƒ",
            filetypes=[("EPUB files", "*.epub")]
        )
        if not files:
            return
        self.epub_paths.extend(files)
        self._maybe_resort()
        self._refresh_list()

    def _remove_selected(self):
        sel = list(self.listbox.curselection())
        if not sel:
            return
        for idx in reversed(sel):
            del self.epub_paths[idx]
        self._refresh_list()

    def _clear_all(self):
        self.epub_paths = []
        self._refresh_list()

    def _move_up(self):
        sel = self.listbox.curselection()
        if not sel:
            return
        idx = sel[0]
        if idx == 0:
            return
        self.epub_paths[idx - 1], self.epub_paths[idx] = self.epub_paths[idx], self.epub_paths[idx - 1]
        self._refresh_list()
        self.listbox.selection_set(idx - 1)

    def _move_down(self):
        sel = self.listbox.curselection()
        if not sel:
            return
        idx = sel[0]
        if idx >= len(self.epub_paths) - 1:
            return
        self.epub_paths[idx + 1], self.epub_paths[idx] = self.epub_paths[idx], self.epub_paths[idx + 1]
        self._refresh_list()
        self.listbox.selection_set(idx + 1)

    def _maybe_resort(self):
        if self.auto_sort_var.get():
            self._sort_paths()
            self._refresh_list()

    def _sort_paths(self):
        mode = self.mode_var.get()
        if mode == "volume":
            self.epub_paths.sort(
                key=lambda p: _volume_sort_key_from_basename(os.path.basename(p))
            )
        else:
            def num(name: str):
                for pat in [r"\((\d+)\s*~", r"(\d+)\s*í™”", r"(\d+)\s*ê¶Œ", r"(\d+)"]:
                    m = re.search(pat, name)
                    if m:
                        return int(m.group(1))
                return None

            def is_extra(name: str) -> int:
                return 1 if re.search(r"(ì™¸ì „|ë²ˆì™¸|íŠ¹ë³„í¸|ì—í•„ë¡œê·¸)", name) else 0

            withn, without = [], []
            for p in self.epub_paths:
                base = os.path.basename(p)
                n = num(base)
                if n is None:
                    without.append(p)
                else:
                    extra_flag = is_extra(base)
                    withn.append((extra_flag, n, base, p))

            withn.sort(key=lambda x: (x[0], x[1], x[2]))
            self.epub_paths = [p for _, _, _, p in withn] + without

    def _refresh_list(self):
        self.listbox.delete(0, "end")
        for p in self.epub_paths:
            self.listbox.insert("end", os.path.basename(p))

    # ------------- ì €ì¥ ìœ„ì¹˜ -------------
    def _choose_outdir(self):
        d = filedialog.askdirectory(title="ì¶œë ¥ í´ë” ì„ íƒ", initialdir=self.last_output_dir)
        if d:
            self.last_output_dir = d
            self.out_entry.delete(0, "end")
            self.out_entry.insert(0, d)
            try:
                with open(CONFIG_PATH, "w", encoding="utf-8") as f:
                    json.dump({"last_output_dir": d}, f, ensure_ascii=False, indent=2)
            except Exception:
                pass

    # ------------- ë¡œê·¸/ì§„í–‰ë°” -------------
    def _log(self, msg: str):
        self.log_text.insert("end", msg + "\n")
        self.log_text.see("end")
        self.window.update_idletasks()


if __name__ == "__main__":
    if DND_AVAILABLE:
        root = TkinterDnD.Tk()
        style = tb.Style("cosmo")
        style.master = root
        app = App(root, dnd_enabled=True)
        root.mainloop()
    else:
        win = tb.Window(themename="cosmo")
        app = App(win, dnd_enabled=False)
        win.mainloop()
# EPUB í•©ë³¸ í”„ë¡œê·¸ë¨ ë©”ì¸ ì½”ë“œ (ìº”ë²„ìŠ¤ ì´ˆì•ˆ)
# ì—¬ê¸°ë¶€í„° ìš°ë¦¬ê°€ íŒ¨ì¹˜ ë‹¨ìœ„ë¡œ ìˆ˜ì •í•´ ë‚˜ê°ˆ ê±°ì•¼.
